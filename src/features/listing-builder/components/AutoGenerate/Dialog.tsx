import { useChat } from '@ai-sdk/react';
import { useMutation } from '@tanstack/react-query';
import { DefaultChatTransport } from 'ai';
import { useAtom, useSetAtom } from 'jotai';
import { marked } from 'marked';
import { AnimatePresence, motion } from 'motion/react';
import { useRouter } from 'next/router';
import posthog from 'posthog-js';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

import {
  type RewardInputSchema,
  type TRewardsGenerateResponse,
} from '@/app/api/sponsor-dashboard/ai-generate/rewards/route';
import { type TTitleGenerateResponse } from '@/app/api/sponsor-dashboard/ai-generate/title/route';
import { type TTokenGenerateResponse } from '@/app/api/sponsor-dashboard/ai-generate/token/route';
import { AnimateChangeInHeight } from '@/components/shared/AnimateChangeInHeight';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent } from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { tokenList } from '@/constants/tokenList';
import { type BountyType } from '@/generated/prisma/enums';
import { type Skills } from '@/interface/skills';
import { api } from '@/lib/api';
import { type HackathonModel } from '@/prisma/models/Hackathon';
import { useUser } from '@/store/user';
import { cn } from '@/utils/cn';

import { fetchTokenUSDValue } from '@/features/wallet/utils/fetchTokenUSDValue';

import {
  generatedListingAtom,
  type GeneratedListingData,
  isAutoGenerateOpenAtom,
} from '../../atoms';
import { type TEligibilityQuestion } from '../../types/schema';
import { AutoGenerateChat } from './Chat';
import { prepareCompanyInfo } from './company-info';
import { AutoGenerateForm } from './Form';
import { AutoGenerateStageType } from './Type';

function adjustPrompt(prompt: string, refine: boolean) {
  if (refine) {
    return `
    This is a refine request, so iterate the previous output based on current input.
    Directly provide the output description, do not include any other text like greeting, reasoning, etc.
    User Message: ${prompt}
    `;
  }
  return `
  Directly provide the output description, do not include any other text like greeting, reasoning, etc
  User Message: ${prompt}
  `;
}

export function AutoGenerateDialog({
  hackathons,
}: {
  hackathons?: HackathonModel[];
}) {
  const [stage, setStage] = useState<'type' | 'form' | 'chat'>('type');
  const [type, setType] = useState<BountyType>('bounty');
  const [open, setOpen] = useAtom(isAutoGenerateOpenAtom);
  const [input, setInput] = useState('');
  const [originalPrompt, setOriginalPrompt] = useState('');
  const setGeneratedListing = useSetAtom(generatedListingAtom);
  const { user } = useUser();
  const router = useRouter();
  const [tokenUsdValue, setTokenUsdValue] = useState<number>(1);
  const [proceedLoading, setProceedLoading] = useState(false);
  const [proceedDisabled, setProceedDisabled] = useState(true);
  const [isThinking, setIsThinking] = useState(false);
  const [hackathonSlug, setHackathonSlug] = useState<string>('');
  const [showCloseConfirm, setShowCloseConfirm] = useState(false);
  const generatedDataRef = useRef<{
    isReady: boolean;
    title?: typeof title;
    rewards?: typeof rewards;
    skills?: typeof skills;
    eligibilityQuestions?: typeof eligibilityQuestions;
  }>({ isReady: false });
  const hasExecutedRef = useRef(true);

  const [scrollEl, setScrollEl] = useState<HTMLDivElement | null>(null);

  const scrollCallbackRef = useCallback((node: HTMLDivElement | null) => {
    if (node !== null) {
      setScrollEl(node);
    }
  }, []);

  const { messages, sendMessage, status, setMessages } = useChat({
    transport: new DefaultChatTransport({
      api: '/api/sponsor-dashboard/ai-generate/description',
    }),
    experimental_throttle: 100,
  });

  const { data: token, mutateAsync: callToken } = useMutation({
    mutationFn: async ({ description }: { description: string }) =>
      (
        await api.post<TTokenGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/token',
          {
            description,
          },
        )
      ).data,
  });

  const { data: title, mutateAsync: callTitle } = useMutation({
    mutationFn: async ({
      description,
      type,
    }: {
      description: string;
      type: BountyType;
    }) =>
      (
        await api.post<TTitleGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/title',
          { description, type },
        )
      ).data,
  });

  const { data: eligibilityQuestions, mutateAsync: callEligibilityQuestions } =
    useMutation({
      mutationFn: async ({
        description,
        type,
      }: {
        description: string;
        type: BountyType;
      }) =>
        type !== 'hackathon'
          ? (
              await api.post<TEligibilityQuestion[]>(
                '/api/sponsor-dashboard/ai-generate/questions',
                {
                  description,
                  type,
                },
              )
            ).data
          : undefined,
    });

  const { data: rewards, mutateAsync: callRewards } = useMutation({
    mutationFn: async (input: RewardInputSchema) =>
      (
        await api.post<TRewardsGenerateResponse>(
          '/api/sponsor-dashboard/ai-generate/rewards',
          input,
        )
      ).data,
  });

  const { data: skills, mutateAsync: callSkills } = useMutation({
    mutationFn: async ({ description }: { description: string }) =>
      (
        await api.post<Skills>('/api/sponsor-dashboard/ai-generate/skills', {
          description,
        })
      ).data,
  });

  const handleTypeSelect = (type: BountyType) => {
    posthog.capture('select type_auto-generate', { type });
    setType(type);
    setStage('form');
  };

  const handleHackathonSelect = (hackathon: string) => {
    posthog.capture('select hackathon_auto-generate', { hackathon });
    setHackathonSlug(hackathon);
  };

  const handleSendMessage = async (refine: boolean = false) => {
    if (refine) posthog.capture('refine_auto-generate');
    else posthog.capture('generate_auto-generate');
    const text = input;
    setInput('');

    if (!refine) {
      setOriginalPrompt(text);
    }

    setStage('chat');
    generatedDataRef.current = { isReady: false };
    setProceedDisabled(true);
    setIsThinking(true);
    const token = (await callToken({ description: text }))?.token || 'USDC';
    const tokenItem = tokenList.find((s) => s.tokenSymbol === token);
    const tokenUsdAmount = tokenItem
      ? await fetchTokenUSDValue(tokenItem.mintAddress)
      : 1;
    setTokenUsdValue(tokenUsdAmount);
    await sendMessage(
      {
        role: 'user',
        parts: [{ type: 'text', text: adjustPrompt(text, refine) }],
      },
      {
        body: {
          token,
          tokenUsdAmount,
          company: user?.currentSponsor
            ? prepareCompanyInfo(user?.currentSponsor)
            : 'unknown sponsor',
          listingType: type,
          hackathonName: hackathonSlug
            ? hackathons?.find((h) => h.slug === hackathonSlug)?.name
            : undefined,
        },
      },
    );
    setProceedDisabled(false);
  };

  useEffect(() => {
    console.log(status);
    console.log(messages);
    console.log('isDataReady', generatedDataRef.current.isReady);
  }, [messages, status]);

  useEffect(() => {
    if (open) {
      router.prefetch('/dashboard/new');
    }
  }, [open, router]);

  const description = useMemo(() => {
    return (
      [...messages]
        ?.filter((message) => message.role === 'assistant')
        ?.pop()
        ?.parts.filter((part) => part.type === 'text')
        ?.map((part) => part.text)
        .join('') || ''
    );
  }, [messages]);

  useEffect(() => {
    const lastMessage = [...messages]?.pop();
    if (
      lastMessage?.role === 'assistant' &&
      lastMessage?.parts.filter((part) => part.type === 'text').length > 0 &&
      description?.length > 0
    ) {
      setIsThinking(false);
    }
  }, [messages, description]);

  useEffect(() => {
    if (status === 'streaming') {
      hasExecutedRef.current = false;
    }
  }, [status]);

  useEffect(() => {
    if (status === 'error') {
      const lastUserMessage = [...messages]
        .filter((message) => message.role === 'user')
        .pop();

      if (lastUserMessage) {
        const lastUserText = lastUserMessage.parts
          .filter((part) => part.type === 'text')
          .map((part) => part.text)
          .join('');
        setInput(lastUserText);
      }
    }
  }, [status, messages]);

  useEffect(() => {
    if (
      !hasExecutedRef.current &&
      status === 'ready' &&
      description?.length > 0
    ) {
      hasExecutedRef.current = true;
      generatedDataRef.current = { isReady: false };
      Promise.all([
        callTitle({ description, type }),
        callEligibilityQuestions({ description, type }),
        callRewards({
          description,
          type,
          token: token?.token || 'USDC',
          tokenUsdValue,
        }),
        callSkills({ description }),
      ]).then(
        ([titleResult, eligibilityResult, rewardsResult, skillsResult]) => {
          generatedDataRef.current = {
            isReady: true,
            title: titleResult,
            rewards: rewardsResult,
            skills: skillsResult,
            eligibilityQuestions: eligibilityResult,
          };
        },
      );
    } else {
      generatedDataRef.current = { isReady: false };
    }
  }, [description, status, type, token?.token, tokenUsdValue]);

  const handleProceed = async () => {
    posthog.capture('proceed_auto-generate');
    setProceedLoading(true);

    console.log('isDataReady in proceed', generatedDataRef.current.isReady);
    while (!generatedDataRef.current.isReady) {
      console.log(
        'waiting for data, isReady:',
        generatedDataRef.current.isReady,
      );
      await new Promise((resolve) => setTimeout(resolve, 250));
    }

    const html = await marked.parse(description || '', { gfm: true });

    const processedHtml = html.replace(
      /<a\s+(?:[^>]*?\s+)?href=(["'])(.*?)\1/g,
      '<a href=$1$2$1 target="_blank" rel="noopener noreferrer"',
    );

    const { title, rewards, skills, eligibilityQuestions } =
      generatedDataRef.current;

    const generatedData: GeneratedListingData = {
      description: processedHtml,
      token: token?.token,
      title: title?.title,
      rewards,
      skills,
      eligibilityQuestions,
      type,
    };

    setGeneratedListing(generatedData);
    await router.push(
      `/dashboard/new?type=${type}&autogenerated=true${
        type === 'hackathon' ? `&hackathon=${hackathonSlug}` : ''
      }`,
    );
    setOpen(false);
    setProceedLoading(false);
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(open) => {
        if (!open) posthog.capture('close_auto-generate');
        else posthog.capture('open_auto-generate');
        setOpen(open);
      }}
    >
      <DialogContent
        className={cn(
          'gap-0 overflow-hidden border-0 p-0 focus-visible:ring-0 sm:max-w-160',
          // stage === 'type' && 'sm:max-w-5xl',
        )}
        style={{
          borderImageWidth: '0px !important',
        }}
        aria-describedby="Auto Generate Listing"
        hideCloseIcon
        autoFocus={false}
        onInteractOutside={(e) => {
          if (stage === 'chat' && description.length > 0) {
            e.preventDefault();
            setShowCloseConfirm(true);
          }
        }}
        onEscapeKeyDown={(e) => {
          if (stage === 'chat' && description.length > 0) {
            e.preventDefault();
            setShowCloseConfirm(true);
          }
        }}
      >
        <button className="sr-only" />
        <ScrollArea
          type="scroll"
          className={cn(
            'relative max-h-160 py-0',
            // stage === 'type' ? 'max-h-screen' : 'max-h-160',
          )}
          viewportProps={{
            ref: scrollCallbackRef,
            className: 'h-full *:h-full',
          }}
        >
          <AnimateChangeInHeight disableOnHeightZero className="box-border">
            <div className={cn('h-full p-0')}>
              <AnimatePresence mode="popLayout">
                <motion.div
                  initial={{
                    opacity: 0,
                    transform: 'translateY(-30px)',
                    filter: 'blur(4px)',
                  }}
                  animate={{
                    opacity: 1,
                    transform: 'translateY(0px)',
                    filter: 'blur(0px)',
                  }}
                  exit={{
                    opacity: 0,
                    transform: 'translateY(30px)',
                    filter: 'blur(4px)',
                  }}
                  transition={{
                    type: 'spring',
                    bounce: 0,
                    duration: 0.4,
                  }}
                  key={stage}
                >
                  {stage === 'type' && (
                    <AutoGenerateStageType
                      type={type}
                      setType={handleTypeSelect}
                      hackathons={hackathons}
                      setHackathonSlug={handleHackathonSelect}
                      hackathonSlug={hackathonSlug}
                      input={input}
                      setInput={setInput}
                    />
                  )}
                  {stage === 'form' && (
                    <AutoGenerateForm
                      type={type}
                      setType={handleTypeSelect}
                      input={input}
                      setInput={setInput}
                      onSubmit={() => handleSendMessage(false)}
                      setHackathonSlug={handleHackathonSelect}
                      hackathonSlug={hackathonSlug}
                      hackathons={hackathons}
                    />
                  )}
                  {stage === 'chat' && (
                    <AutoGenerateChat
                      handleProceed={handleProceed}
                      description={description}
                      isThinking={isThinking}
                      error={status === 'error'}
                      loading={status === 'streaming'}
                      input={input}
                      setInput={setInput}
                      handleRefine={() => handleSendMessage(true)}
                      handleBack={() => {
                        posthog.capture('back_auto-generate');
                        setStage('form');
                        setMessages([]);
                        setInput(originalPrompt);
                      }}
                      scrollEl={scrollEl}
                      isDisabled={proceedDisabled}
                      isLoading={proceedLoading}
                      isRefineDisabled={input.length === 0}
                      messages={messages}
                    />
                  )}
                </motion.div>
              </AnimatePresence>
            </div>
          </AnimateChangeInHeight>
        </ScrollArea>
      </DialogContent>

      <Dialog open={showCloseConfirm} onOpenChange={setShowCloseConfirm}>
        <DialogContent
          className={cn('p-0 sm:max-w-md')}
          aria-describedby="Close confirmation"
        >
          <Alert className="border-0 p-6">
            <AlertTitle className="mb-2 text-base">Are you sure?</AlertTitle>
            <AlertDescription className="text-slate-400">
              Are you sure you want to close this window? You might lose your
              progress.
            </AlertDescription>
            <div className="mt-6 flex items-center justify-end gap-3">
              <Button
                variant="outline"
                onClick={() => {
                  posthog.capture('keep_editing_auto-generate');
                  setShowCloseConfirm(false);
                }}
              >
                Keep Editing
              </Button>
              <Button
                onClick={() => {
                  posthog.capture('discard_draft_auto-generate');
                  setShowCloseConfirm(false);
                  setOpen(false);
                }}
              >
                Discard Draft
              </Button>
            </div>
          </Alert>
        </DialogContent>
      </Dialog>
    </Dialog>
  );
}
